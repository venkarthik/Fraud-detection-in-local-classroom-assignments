"use strict";
const DOMException = require("domexception/webidl2js-wrapper");
const FileList = require("../generated/FileList");
const Decimal = require("decimal.js");
const HTMLElementImpl = require("./HTMLElement-impl").implementation;
const idlUtils = require("../generated/utils");
const DefaultConstraintValidationImpl =
  require("../constraint-validation/DefaultConstraintValidation-impl").implementation;
const ValidityState = require("../generated/ValidityState");
const { mixin } = require("../../utils");
const { domSymbolTree, cloningSteps } = require("../helpers/internal-constants");
const { getLabelsForLabelable, formOwner } = require("../helpers/form-controls");
const { fireAnEvent } = require("../helpers/events");
const {
  isDisabled,
  isValidEmailAddress,
  isValidAbsoluteURL,
  sanitizeValueByType
} = require("../helpers/form-controls");
const {
  asciiCaseInsensitiveMatch,
  asciiLowercase,
  parseFloatingPointNumber,
  splitOnCommas
} = require("../helpers/strings");
const { isDate } = require("../helpers/dates-and-times");
const {
  convertStringToNumberByType,
  convertStringToDateByType,
  serializeDateByType,
  convertNumberToStringByType
} = require("../helpers/number-and-date-inputs");

const filesSymbol = Symbol("files");

// https://html.spec.whatwg.org/multipage/input.html#attr-input-type
const inputAllowedTypes = new Set([
  "hidden", "text", "search", "tel", "url", "email", "password", "date",
  "month", "week", "time", "datetime-local", "number", "range", "color", "checkbox", "radio",
  "file", "submit", "image", "reset", "button"
]);

// https://html.spec.whatwg.org/multipage/input.html#concept-input-apply

const variableLengthSelectionAllowedTypes = new Set(["text", "search", "url", "tel", "password"]);
const numericTypes = new Set(["date", "month", "week", "time", "datetime-local", "number", "range"]);

const applicableTypesForIDLMember = {
  valueAsDate: new Set(["date", "month", "week", "time"]),
  valueAsNumber: numericTypes,

  select: new Set([
    "text", "search", "url", "tel", "email", "password", "date", "month", "week",
    "time", "datetime-local", "number", "color", "file"
  ]),
  selectionStart: variableLengthSelectionAllowedTypes,
  selectionEnd: variableLengthSelectionAllowedTypes,
  selectionDirection: variableLengthSelectionAllowedTypes,
  setRangeText: variableLengthSelectionAllowedTypes,
  setSelectionRange: variableLengthSelectionAllowedTypes,
  stepDown: numericTypes,
  stepUp: numericTypes
};

const lengthPatternSizeTypes = new Set(["text", "search", "url", "tel", "email", "password"]);
const readonlyTypes =
  new Set([...lengthPatternSizeTypes, "date", "month", "week", "time", "datetime-local", "number"]);

const applicableTypesForContentAttribute = {
  list: new Set(["text", "search", "url", "tel", "email", ...numericTypes, "color"]),
  max: numericTypes,
  maxlength: lengthPatternSizeTypes,
  min: numericTypes,
  minlength: lengthPatternSizeTypes,
  multiple: new Set(["email", "file"]),
  pattern: lengthPatternSizeTypes,
  readonly: readonlyTypes,
  required: new Set([...readonlyTypes, "checkbox", "radio", "file"]),
  step: numericTypes
};

const valueAttributeDefaultMode = new Set(["hidden", "submit", "image", "reset", "button"]);
const valueAttributeDefaultOnMode = new Set(["checkbox", "radio"]);

function valueAttributeMode(type) {
  if (valueAttributeDefaultMode.has(type)) {
    return "default";
  }
  if (valueAttributeDefaultOnMode.has(type)) {
    return "default/on";
  }
  if (type === "file") {
    return "filename";
  }
  return "value";
}

function getTypeFromAttribute(typeAttribute) {
  if (typeof typeAttribute !== "string") {
    return "text";
  }
  const type = asciiLowercase(typeAttribute);
  return inputAllowedTypes.has(type) ? type : "text";
}

class HTMLInputElementImpl extends HTMLElementImpl {
  constructor(globalObject, args, privateData) {
    super(globalObject, args, privateData);

    this._selectionStart = this._selectionEnd = 0;
    this._selectionDirection = "none";
    this._value = "";
    this._dirtyValue = false;
    this._checkedness = false;
    this._dirtyCheckedness = false;

    this._preCheckedRadioState = null;
    this._legacyActivationBehaviorPreviousIndeterminateState = false;

    this.indeterminate = false;

    this._customValidityErrorMessage = "";

    this._labels = null;

    this._hasActivationBehavior = true;
  }

  // https://html.spec.whatwg.org/multipage/input.html#concept-input-value-string-number
  get _convertStringToNumber() {
    return convertStringToNumberByType[this.type];
  }

  get _convertNumberToString() {
    return convertNumberToStringByType[this.type];
  }

  get _convertDateToString() {
    return serializeDateByType[this.type];
  }

  get _convertStringToDate() {
    return convertStringToDateByType[this.type];
  }

  _isStepAligned(v) {
    return new Decimal(v).minus(this._stepBase)
      .modulo(this._allowedValueStep)
      .isZero();
  }

  // Returns a Decimal.
  _stepAlign(v, roundUp) {
    const allowedValueStep = this._allowedValueStep;
    const stepBase = this._stepBase;

    return new Decimal(v).minus(stepBase)
      .toNearest(allowedValueStep, roundUp ? Decimal.ROUND_UP : Decimal.ROUND_DOWN)
      .add(stepBase);
  }

  // For <input>, https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#concept-fe-value
  // is a simple value that is gotten and set, not computed.
  _getValue() {
    return this._value;
  }

  _legacyPreActivationBehavior() {
    if (this.type === "checkbox") {
      this.checked = !this.checked;
      this._legacyActivationBehaviorPreviousIndeterminateState = this.indeterminate;
      this.indeterminate = false;
    } else if (this.type === "radio") {
      this._preCheckedRadioState = this.checked;
      this.checked = true;
    }
  }

  _legacyCanceledActivationBehavior() {
    if (this.type === "checkbox") {
      this.checked = !this.checked;
      this.indeterminate = this._legacyActivationBehaviorPreviousIndeterminateState;
    } else if (this.type === "radio") {
      if (this._preCheckedRadioState !== null) {
        this.checked = this._preCheckedRadioState;
        this._preCheckedRadioState = null;
      }
    }
  }

  _activationBehavior() {
    if (!this._mutable && this.type !== "checkbox" && this.type !== "radio") {
      return;
    }

    const { form } = this;

    if (this.type === "checkbox" || (this.type === "radio" && !this._preCheckedRadioState)) {
      if (this.isConnected) {
        fireAnEvent("input", this, undefined, { bubbles: true });
        fireAnEvent("change", this, undefined, { bubbles: true });
      }
    } else if (form && this.type === "submit") {
      form._doSubmit();
    } else if (form && this.type === "reset") {
      form._doReset();
    }
  }

  _attrModified(name, value, oldVal) {
    const wrapper = idlUtils.wrapperForImpl(this);
    if (!this._dirtyValue && name === "value") {
      this._value = sanitizeValueByType(this, wrapper.defaultValue);
    }
    if (!this._dirtyCheckedness && name === "checked") {
      this._checkedness = wrapper.defaultChecked;
      if (this._checkedness) {
        this._removeOtherRadioCheckedness();
      }
    }

    if (name === "name" || name === "type") {
      if (this._checkedness) {
        this._removeOtherRadioCheckedness();
      }
    }

    if (name === "type") {
      const prevType = getTypeFromAttribute(oldVal);
      const curType = getTypeFromAttribute(value);
      // When an input element's type attribute changes stateâ€¦
      if (prevType !== curType) {
        const prevValueMode = valueAttributeMode(prevType);
        const curValueMode = valueAttributeMode(curType);
        if (prevValueMode === "value" && this._value !== "" &&
            (curValueMode === "default" || curValueMode === "default/on")) {
          this.setAttributeNS(null, "value", this._value);
        } else if (prevValueMode !== "value" && curValueMode === "value") {
          this._value = this.getAttributeNS(null, "value") || "";
          this._dirtyValue = false;
        } else if (prevValueMode !== "filename" && curValueMode === "filename") {
          this._value = "";
        }

        this._signalATypeChange();

        this._value = sanitizeValueByType(this, this._value);

        const previouslySelectable = this._idlMemberApplies("setRangeText", prevType);
        const nowSelectable = this._idlMemberApplies("setRangeText", curType);
        if (!previouslySelectable && nowSelectable) {
          this._selectionStart = 0;
          this._selectionEnd = 0;
          this._selectionDirection = "none";
        }
      }
    }

    super._attrModified(name, value, oldVal);
  }

  // https://html.spec.whatwg.org/multipage/input.html#signal-a-type-change
  _signalATypeChange() {
    if (this._checkedness) {
      this._removeOtherRadioCheckedness();
    }
  }

  _formReset() {
    const wrapper = idlUtils.wrapperForImpl(this);
    this._value = sanitizeValueByType(this, wrapper.defaultValue);
    this._dirtyValue = false;
    this._checkedness = wrapper.defaultChecked;
    this._dirtyCheckedness = false;
    if (this._checkedness) {
      this._removeOtherRadioCheckedness();
    }
  }

  _changedFormOwner() {
    if (this._checkedness) {
      this._removeOtherRadioCheckedness();
    }
  }

  get _otherRadioGroupElements() {
    const wrapper = idlUtils.wrapperForImpl(this);
    const root = this._radioButtonGroupRoot;
    if (!root) {
      return [];
    }

    const result = [];

    const descendants = domSymbolTree.treeIterator(root);
    for (const candidate of descendants) {
      if (candidate._radioButtonGroupRoot !== root) {
        continue;
      }

      const candidateWrapper = idlUtils.wrapperForImpl(candidate);
      if (!candidateWrapper.name || candidateWrapper.name !== wrapper.name) {
        continue;
      }

      if (candidate !== this) {
        result.push(candidate);
      }
    }
    return result;
  }

  _removeOtherRadioCheckedness() {
    for (const radioGroupElement of 